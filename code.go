// Copyright (C) 2025 jay-babu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package problem

// TODO: Consider moving "code" etc out to separate library and recommend use via extension as not part of RFC

import (
	"errors"
	"fmt"
	"math"
	"regexp"
	"strconv"
	"strings"
	"unicode"
)

type (
	// Code is intended to be a unique string that identifies a specific occurrence of a Problem.
	//
	// Consumers can use a Code to communicate with the owner of the generator to help debug a problem and the client
	// can use it to handle a specific occurrence of a problem without risk of conflicts with other problems using the
	// same status, title, and/or type URI reference.
	//
	// A well-formed Code is expected to be formed of a namespace (CodeNamespace) and a numeric value, separated using
	// Generator.CodeSeparator.
	//
	// While Code is not strictly associated with problems, it is common for such a concept to be used in combination
	// and so is provided as an optional extra.
	//
	// Since Code is just a string, there's nothing to prevent a Code being explicitly declared, for example;
	//
	//	code := Code("AUTH-400")
	//
	// However, this is discouraged in favor of using Builder.Code or WithCode to construct consistent codes that
	// conform to validation defined on a Generator. That said; it really just depends on how important Code consistency
	// is to the generator.
	Code string

	// CodeNamespace represents a namespace within the problem generator (e.g. web application). It can be used to
	// distinguish problems generated by different logical locations within the code base. This allows generic and
	// possibly conflicting Code values to be reused across multiple namespaces while not inhibiting debugging.
	//
	// For example; a problem generated within an authentication service may use a CodeNamespace of "AUTH" while a user
	// service may use a CodeNamespace of "USER".
	CodeNamespace string

	// CodeNamespaceValidator is a function used validate a given CodeNamespace when a Generator is constructing or
	// parsing a Code.
	//
	// Such validation can be useful to ensure each CodeNamespace used meets a standard.
	//
	// The error returned should not be an ErrCode as a Generator will wrap it in an ErrCode.
	CodeNamespaceValidator func(namespace CodeNamespace) error

	// ParsedCode contains any information parsed from a Code, including the original Code.
	ParsedCode struct {
		// Code is the Code which was parsed.
		Code Code
		// Namespace is the namespace found within the parsed Code.
		Namespace CodeNamespace
		// Value is the value found within the parsed Code.
		Value uint
	}
)

// DefaultCodeSeparator is the default rune used to separate the CodeNamespace and value of a Code and is used by
// DefaultGenerator.
const DefaultCodeSeparator rune = '-'

// ErrCode is returned when a Code cannot be constructed or parsed.
var ErrCode = errors.New("invalid problem code")

// ComposeCodeNamespaceValidator returns a CodeNamespaceValidator composed of each of the given validators.
//
// For example;
//
//	ComposeCodeNamespaceValidator(
//		LenCodeNamespaceValidator(4, 8),
//		UnicodeCodeNamespaceValidator(unicode.IsUpper, unicode.ToUpper),
//	)
func ComposeCodeNamespaceValidator(validators ...CodeNamespaceValidator) CodeNamespaceValidator {
	return func(namespace CodeNamespace) error {
		for _, validator := range validators {
			if err := validator(namespace); err != nil {
				return err
			}
		}
		return nil
	}
}

// LenCodeNamespaceValidator returns a CodeNamespaceValidator that asserts that a CodeNamespace contains at least the
// minimum and, optionally, at most the maximum number of characters. Otherwise, an error is returned.
//
// Since Generator validates that a CodeNamespace is not empty by default, min must be at least one and, if max is
// provided, must be greater than or equal to min.
//
// For example;
//
//	LenCodeNamespaceValidator(4)
//	LenCodeNamespaceValidator(4, 8)
func LenCodeNamespaceValidator(min int, max ...int) CodeNamespaceValidator {
	var _max int
	if len(max) > 0 {
		_max = max[0]
	} else {
		_max = math.MaxInt
	}
	return func(namespace CodeNamespace) error {
		if min < 1 {
			return fmt.Errorf("LenCodeNamespaceValidator min is less than min (want 1, got %v)", min)
		} else if _max < min {
			return fmt.Errorf("LenCodeNamespaceValidator max is less than min (want %v, got %v)", min, _max)
		} else if l := len(namespace); l < min {
			return fmt.Errorf("CodeNamespace contains too few characters (want %v, got %v): %q", min, l, namespace)
		} else if l > _max {
			return fmt.Errorf("CodeNamespace contains too many characters (want %v, got %v): %q", _max, l, namespace)
		}
		return nil
	}
}

// RegexpCodeNamespaceValidator returns a CodeNamespaceValidator that asserts that a CodeNamespace matches the given
// regular expression. Otherwise, an error is returned.
//
// If expr fails to compile into a regexp.Regexp, an error is always returned.
//
// For example;
//
//	RegexpCodeNamespaceValidator(`[a-zA-Z]+`)
func RegexpCodeNamespaceValidator(expr string) CodeNamespaceValidator {
	r, err := regexp.Compile(expr)
	return func(namespace CodeNamespace) error {
		if err != nil {
			return fmt.Errorf("RegexpCodeNamespaceValidator expr could not be compiled: %q: %w", expr, err)
		} else if !r.MatchString(string(namespace)) {
			return fmt.Errorf("CodeNamespace does not match regexp (want %q): %q", expr, namespace)
		}
		return nil
	}
}

// UnicodeCodeNamespaceValidator returns a CodeNamespaceValidator that asserts that a CodeNamespace contains only
// unicode runes that meet the given predicate. Otherwise, an error is returned containing the desired rune using
// mapper.
//
// For example;
//
//	UnicodeCodeNamespaceValidator(unicode.IsLower, unicode.ToLower)
//	UnicodeCodeNamespaceValidator(unicode.IsUpper, unicode.ToUpper)
func UnicodeCodeNamespaceValidator(predicate func(r rune) bool, mapper func(r rune) rune) CodeNamespaceValidator {
	return func(namespace CodeNamespace) error {
		for i, r := range namespace {
			if !predicate(r) {
				return fmt.Errorf("CodeNamespace contains invalid character at index %v (want %q, got %q): %q", i, mapper(r), r, namespace)
			}
		}
		return nil
	}
}

// BuildCode returns a constructed Code using the given value, if able.
//
// CodeNamespace is required as it's used during the construction and is separated from value using
// Generator.CodeSeparator.
//
// An ErrCode is returned only in the following cases:
//   - Generator.CodeSeparator is a non-printable rune
//   - Generator.ValidateCodeNamespace rejects namespace
//   - Generator.ValidateCodeValue rejects value
func (g *Generator) BuildCode(value uint, namespace CodeNamespace) (Code, error) {
	sep, err := g.codeSeparator()
	if err != nil {
		return "", err
	}

	suffix := strconv.FormatUint(uint64(value), 10)
	if err = g.validateCodeValue(suffix); err != nil {
		return "", err
	}
	if vl := g.CodeValueLen; vl > 0 {
		for len(suffix) < vl {
			suffix += "0"
		}
	}

	if err = g.validateCodeNamespace(namespace, sep); err != nil {
		return "", err
	}

	var sb strings.Builder
	sb.WriteString(string(namespace))
	sb.WriteRune(sep)
	sb.WriteString(suffix)
	return Code(sb.String()), nil
}

// MustBuildCode is a convenient shorthand for calling Generator.BuildCode that panics if it returns an error.
func (g *Generator) MustBuildCode(value uint, namespace CodeNamespace) Code {
	if code, err := g.BuildCode(value, namespace); err != nil {
		panic(err)
	} else {
		return code
	}
}

// MustParseCode is a convenient shorthand for calling Generator.ParseCode that panics if it returns an error.
func (g *Generator) MustParseCode(code Code, namespace ...CodeNamespace) ParsedCode {
	if parsed, err := g.ParseCode(code, namespace...); err != nil {
		panic(err)
	} else {
		return parsed
	}
}

// MustValidateCode is a convenient shorthand for calling Generator.ValidateCode that panics if it returns an error.
func (g *Generator) MustValidateCode(code Code, namespace ...CodeNamespace) {
	if err := g.ValidateCode(code, namespace...); err != nil {
		panic(err)
	}
}

// MustValidateCodeNamespace is a convenient shorthand for calling Generator.ValidateCodeNamespace that panics if it
// returns an error.
func (g *Generator) MustValidateCodeNamespace(namespace CodeNamespace) {
	if err := g.ValidateCodeNamespace(namespace); err != nil {
		panic(err)
	}
}

// MustValidateCodeValue is a convenient shorthand for calling Generator.ValidateCodeBalue that panics if it returns an
// error.
func (g *Generator) MustValidateCodeValue(value uint) {
	if err := g.ValidateCodeValue(value); err != nil {
		panic(err)
	}
}

// ParseCode parses the given Code, if able.
//
// A CodeNamespace is optional but, where present, will result in additional validation on the parsed CodeNamespace,
// asserting that they are equal. Generator.CodeSeparator is used during parsing to separate the CodeNamespace and value
// of the Code.
//
// The returned ParsedCode will contain as much information parsed for code as possible, even though it may be invalid.
// Only when the returned error is nil can it be assumed that ParsedCode contains only valid information.
//
// An ErrCode is returned only in the following cases:
//   - Generator.CodeSeparator is a non-printable rune
//   - Generator.ValidateCodeNamespace rejects the parsed CodeNamespace
//   - Generator.ValidateCodeValue rejects the parsed value, or it cannot be parsed as an uint
func (g *Generator) ParseCode(code Code, namespace ...CodeNamespace) (ParsedCode, error) {
	var ns CodeNamespace
	if len(namespace) > 0 {
		ns = namespace[0]
	}

	pc := ParsedCode{Code: code}
	sep, err := g.codeSeparator()
	if err != nil {
		return pc, err
	}

	var (
		inVal    bool
		nsb, vsb strings.Builder
	)

	for _, r := range code {
		if inVal {
			vsb.WriteRune(r)
		} else if r == sep {
			inVal = true
		} else {
			nsb.WriteRune(r)
		}
	}

	if !inVal {
		return pc, fmt.Errorf("%w: Generator.CodeSeparator %q not found: %q", ErrCode, sep, code)
	}

	pc.Namespace = CodeNamespace(nsb.String())
	if err = g.validateCodeNamespace(pc.Namespace, sep); err != nil {
		return pc, err
	}

	if ns != "" && ns != pc.Namespace {
		return pc, fmt.Errorf("%w: CodeNamespace parsed is unexpected (want %q, got %q): %q", ErrCode, ns, pc.Namespace, code)
	}

	valStr := vsb.String()
	if err = g.validateCodeValue(valStr); err != nil {
		return pc, err
	}

	val, err := strconv.ParseUint(valStr, 10, 0)
	pc.Value = uint(val)
	if err != nil {
		return pc, fmt.Errorf("%w: value cannot be parsed: %q: %w", ErrCode, code, err)
	}

	return pc, nil
}

// ValidateCode validates the given Code and returns an ErrCode if invalid.
//
// A CodeNamespace is optional but, where present, will result in additional validation on the parsed CodeNamespace,
// asserting that they are equal. Generator.CodeSeparator is used during parsing to separate the CodeNamespace and value
// of the Code.
//
// It is effectively a convenient shorthand for calling Generator.ParseCode where only the error is returned.
//
// An ErrCode is returned only in the following cases:
//   - Generator.CodeSeparator is a non-printable rune
//   - Generator.ValidateCodeNamespace rejects the parsed CodeNamespace
//   - Generator.ValidateCodeValue rejects the parsed value, or it cannot be parsed as an uint
func (g *Generator) ValidateCode(code Code, namespace ...CodeNamespace) error {
	_, err := g.ParseCode(code, namespace...)
	return err
}

// ValidateCodeNamespace validates the given CodeNamespace and returns an ErrCode if invalid.
//
// An ErrCode is returned only in the following cases:
//   - Generator.CodeSeparator is a non-printable rune
//   - namespace is empty
//   - namespace contains Generator.CodeSeparator
//   - Generator.CodeNamespaceValidator rejects namespace, if not nil
func (g *Generator) ValidateCodeNamespace(namespace CodeNamespace) error {
	sep, err := g.codeSeparator()
	if err != nil {
		return err
	}
	return g.validateCodeNamespace(namespace, sep)
}

// ValidateCodeValue validates the given value and returns an ErrCode if invalid.
//
// An ErrCode is returned only if the number of digits in the string representation of is greater than
// Generator.CodeValueLen, if greater than zero.
func (g *Generator) ValidateCodeValue(value uint) error {
	s := strconv.FormatUint(uint64(value), 10)
	return g.validateCodeValue(s)
}

// codeSeparator returns the rune to be used to separate the CodeSeparator and value of a Code.
//
// If Generator.CodeSeparator is less than or equal to zero, DefaultCodeSeparator is returned, If
// Generator.CodeSeparator is a printable rune, it is returned. Otherwise, an ErrCode is returned.
func (g *Generator) codeSeparator() (rune, error) {
	if sep := g.CodeSeparator; sep <= 0 {
		return DefaultCodeSeparator, nil
	} else if unicode.IsPrint(sep) {
		return sep, nil
	} else {
		return sep, fmt.Errorf("%w: Generator.CodeSeparator is not printable: %q", ErrCode, sep)
	}
}

// validateCodeNamespace validates the given CodeNamespace and returns an ErrCode if invalid.
func (g *Generator) validateCodeNamespace(namespace CodeNamespace, sep rune) error {
	if namespace == "" {
		return fmt.Errorf("%w: CodeNamespace is empty", ErrCode)
	}
	if strings.ContainsRune(string(namespace), sep) {
		return fmt.Errorf("%w: CodeNamespace contains Generator.CodeSeparator: %q", ErrCode, namespace)
	}
	if v := g.CodeNamespaceValidator; v != nil {
		if err := v(namespace); err != nil {
			return fmt.Errorf("%w: %w", ErrCode, err)
		}
	}
	return nil
}

// validateCodeValue validates the given string representation of a value and returns an ErrCode if invalid.
func (g *Generator) validateCodeValue(value string) error {
	if value == "" {
		return fmt.Errorf("%w: value is empty", ErrCode)
	}
	if vl := g.CodeValueLen; vl > 0 {
		if l := len(value); l > vl {
			return fmt.Errorf("%w: value contains too many characters (want %v, got %v): %q", ErrCode, vl, l, value)
		}
	}
	return nil
}

// BuildCode is a convenient shorthand for calling Generator.BuildCode using DefaultGenerator.
func BuildCode(value uint, namespace CodeNamespace) (Code, error) {
	return DefaultGenerator.BuildCode(value, namespace)
}

// MustBuildCode is a convenient shorthand for calling Generator.MustBuildCode using DefaultGenerator.
func MustBuildCode(value uint, namespace CodeNamespace) Code {
	return DefaultGenerator.MustBuildCode(value, namespace)
}

// MustParseCode is a convenient shorthand for calling Generator.MustParseCode using DefaultGenerator and optionally a
// given CodeNamespace.
func MustParseCode(code Code, namespace ...CodeNamespace) ParsedCode {
	return DefaultGenerator.MustParseCode(code, namespace...)
}

// MustValidateCode is a convenient shorthand for calling Generator.MustValidateCode using DefaultGenerator and
// optionally a given CodeNamespace.
func MustValidateCode(code Code, namespace ...CodeNamespace) {
	DefaultGenerator.MustValidateCode(code, namespace...)
}

// MustValidateCodeNamespace is a convenient shorthand for calling Generator.MustValidateCodeNamespace using
// DefaultGenerator.
func MustValidateCodeNamespace(namespace CodeNamespace) {
	DefaultGenerator.MustValidateCodeNamespace(namespace)
}

// MustValidateCodeValue is a convenient shorthand for calling Generator.MustValidateCodeValue using DefaultGenerator.
func MustValidateCodeValue(value uint) {
	DefaultGenerator.MustValidateCodeValue(value)
}

// ParseCode is a convenient shorthand for calling Generator.ParseCode using DefaultGenerator and optionally a given
// CodeNamespace.
func ParseCode(code Code, namespace ...CodeNamespace) (ParsedCode, error) {
	return DefaultGenerator.ParseCode(code, namespace...)
}

// ValidateCode is a convenient shorthand for calling Generator.ValidateCode using DefaultGenerator and optionally a
// given CodeNamespace.
func ValidateCode(code Code, namespace ...CodeNamespace) error {
	return DefaultGenerator.ValidateCode(code, namespace...)
}

// ValidateCodeNamespace is a convenient shorthand for calling Generator.ValidateCodeNamespace using DefaultGenerator.
func ValidateCodeNamespace(namespace CodeNamespace) error {
	return DefaultGenerator.ValidateCodeNamespace(namespace)
}

// ValidateCodeValue is a convenient shorthand for calling Generator.ValidateCodeValue using DefaultGenerator.
func ValidateCodeValue(value uint) error {
	return DefaultGenerator.ValidateCodeValue(value)
}
